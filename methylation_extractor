#!/usr/bin/perl
use warnings;
use strict;
$|++;
use Getopt::Long;
use Cwd;

my @filenames;
my %counting;
my $parent_dir = getcwd();

my %fhs;

my $version = 'v0.6.3';
my ($ignore,$genomic_fasta,$single,$paired,$full,$report,$no_overlap,$merge_non_CpG,$vanilla) = process_commandline();

process_Bismark_results_file();

sub process_commandline{
  my $help;
  my $single_end;
  my $paired_end;
  my $ignore;
  my $genomic_fasta;
  my $full;
  my $report;
  my $extractor_version;
  my $no_overlap;
  my $merge_non_CpG;
  my $vanilla;

  my $command_line = GetOptions ('help|man' => \$help,
				 'p|paired-end' => \$paired_end,
				 's|single-end' => \$single_end,
				 'fasta' => \$genomic_fasta,
				 'ignore=i' => \$ignore,
				 'comprehensive' => \$full,
				 'report' => \$report,
				 'version' => \$extractor_version,
				 'no_overlap' => \$no_overlap,
				 'merge_non_CpG' => \$merge_non_CpG, 
				 'vanilla' => \$vanilla,
				);

  ### EXIT ON ERROR if there were errors with any of the supplied options
  unless ($command_line){
    die "Please respecify command line options\n";
  }

  ### HELPFILE
  if ($help){
    print_helpfile();
    exit;
  }

  if ($extractor_version){
    print << "VERSION";


                           Bismark Methylation Extractor

   Bismark Extractor Version: $version Copyright 2010-12 Felix Krueger, Babraham Bioinformatics
                      www.bioinformatics.bbsrc.ac.uk/projects/


VERSION
    exit;
  }


  ### no files provided
  unless (@ARGV){
    die "You need to provide one or more Bismark files to create an individual C methylation output. Please respecify!\n";
  }
  @filenames = @ARGV;

  warn "\n *** Bismark methylation extractor version $version ***\n\n";

  ### IGNORING <INT> bases at the start of the read when processing the methylation call string
  unless ($ignore){
    $ignore = 0;
  }
  ### PRINT A REPORT
  unless ($report){
    $report = 0;
  }

  ### OLD (VANILLA) OUTPUT FORMAT
  unless ($vanilla){
    $vanilla = 0;
  }

  if ($single_end){
    $paired_end = 0;   ### SINGLE END ALIGNMENTS
  }
  elsif ($paired_end){
    $single_end = 0;   ### PAIRED-END ALIGNMENTS
  }
  else{
    die "Please specify whether the supplied file(s) are in Bismark single-end or paired-end format\n\n";
  }

  ### NO OVERLAP
  if ($no_overlap){
    die "The option '--no_overlap' can only be specified for paired-end input!\n" unless ($paired_end);
  }
  else{
    $no_overlap = 0;
  }

  ### COMPREHENSIVE OUTPUT
  unless ($full){
    $full = 0;
  }

  ### MERGE NON-CpG context
  unless ($merge_non_CpG){
    $merge_non_CpG = 0;
  }

  return ($ignore,$genomic_fasta,$single_end,$paired_end,$full,$report,$no_overlap,$merge_non_CpG,$vanilla);
}


sub process_Bismark_results_file{

  if ($single){
    if ($vanilla){
      warn "Bismark Single-end vanilla format specified\n";
    }
    else{
      warn "Bismark Single-end SAM format specified (default)\n"; # default
    }
  }
  elsif ($paired){
    if ($vanilla){
      warn "Bismark Paired-end vanilla format specified\n";
    }
    else{
      warn "Bismark Paired-end SAM format specified (default)\n"; # default
    }
  }

  if ($ignore){
    warn "First $ignore bases will be disregarded when processing the methylation call string\n";
  }

  if ($full){
    warn "Strand-specific outputs will be skipped. Separate output files for cytosines in CpG, CHG and CHH context will be generated\n";
  }
  if ($merge_non_CpG){
    warn "Merge CHG and CHH context to non-CpG context specified\n";
  }
  warn "\n";

  sleep (3);

  foreach my $filename (@filenames){
    %fhs = ();
    %counting =(
		total_meCHG_count => 0,
		total_meCHH_count => 0,
		total_meCpG_count => 0,
		total_unmethylated_CHG_count => 0,
		total_unmethylated_CHH_count => 0,
		total_unmethylated_CpG_count => 0,
		sequences_count => 0,
	       );
    warn "\nNow reading in Bismark result file $filename\n\n";
    open (IN,$filename) or die "Can't open file $filename: $!\n";

    ### Vanilla and SAM output need to read different numbers of header lines
    if ($vanilla){
      my $bismark_version = <IN>; ## discarding the Bismark version info
      chomp $bismark_version;
      $bismark_version =~ s/\r//; # replaces \r line feed
      $bismark_version =~  s/Bismark version: //;
      if ($bismark_version =~ /^\@/){
	warn "Detected \@ as the first character of the version information. Is it possible that the file is in SAM format?\n\n";
	sleep (2);
      }

      unless ($version eq $bismark_version){
	die "The methylation extractor and Bismark itself need to be of the same version!\n\nVersions used:\nmethylation extractor: '$version'\nBismark: '$bismark_version'\n";
      }
    }
    else{
      # If the read is in SAM format (default) it can either start with @ header lines or start with alignments directly.
      # We are reading from it further down
    }

    my $output_filename = (split (/\//,$filename))[-1];

    ### OPENING OUTPUT-FILEHANDLES
    if ($report){
      my $report_filename = $output_filename;
      $report_filename =~ s/$/_splitting_report.txt/;
      open (REPORT,'>',$report_filename) or die "Failed to write to file $report_filename $!\n";
    }

    if ($report){
      print REPORT "$output_filename\n\n";
      print REPORT "Parameters used to extract methylation information:\n";
      if ($paired){
	if ($vanilla){
	  print REPORT "Bismark result file: paired-end (vanilla Bismark format)\n";
	}
	else{
	  print REPORT "Bismark result file: paired-end (SAM format)\n"; # default
	}
      }

      if ($single){
	if ($vanilla){
	  print REPORT "Bismark result file: single-end (vanilla Bismark format)\n";
	}
	else{
	  print REPORT "Bismark result file: single-end (SAM format)\n"; # default
	}
      }

      if ($ignore){
	print REPORT "Ignoring first $ignore bases\n";
      }

      if ($full){
	print REPORT "Output specified: comprehensive\n";
      }
      else{
	print REPORT "Output specified: strand-specific (default)\n";
      }

      if ($no_overlap){
	print REPORT "No overlapping methylation calls specified\n";
      }
      if ($genomic_fasta){
	print REPORT "Genomic equivalent sequences will be printed out in FastA format\n";
      }
      if ($merge_non_CpG){
	print REPORT "Methylation in CHG and CHH context will be merged into \"non-CpG context\" output\n";
      }

      print REPORT "\n";
    }

    ### CpG-context and non-CpG context. THIS SECTION IS OPTIONAL

    ### if --comprehensive AND --merge_non_CpG was specified we are only writing out one CpG-context and one Any-Other-context result file
    if ($full and $merge_non_CpG){
      my $cpg_output = my $other_c_output = $output_filename;
      ### C in CpG context
      $cpg_output =~ s/^/CpG_context_/;
      open ($fhs{CpG_context},'>',$cpg_output) or die "Failed to write to $cpg_output $! \n";
      print "Writing result file containing methylation information for C in CpG context to $cpg_output\n";
      print {$fhs{CpG_context}} "Bismark methylation extractor version $version\n";

      ### C in any other context than CpG
      $other_c_output =~ s/^/Non_CpG_context_/;
      open ($fhs{other_context},'>',$other_c_output) or die "Failed to write to $other_c_output $!\n";
      print "Writing result file containing methylation information for C in any other context to $other_c_output\n";
      print {$fhs{other_context}} "Bismark methylation extractor version $version\n";
    }

    ### if only --merge_non_CpG was specified we will write out 8 different output files, depending on where the (first) unique best alignment has been found
    elsif ($merge_non_CpG){

      my $cpg_ot = my $cpg_ctot = my $cpg_ctob = my $cpg_ob = $output_filename;

      ### For cytosines in CpG context
      $cpg_ot =~ s/^/CpG_OT_/;
      open ($fhs{0}->{CpG},'>',$cpg_ot) or die "Failed to write to $cpg_ot $!\n";
      print "Writing result file containing methylation information for C in CpG context from the original top strand to $cpg_ot\n";
      print {$fhs{0}->{CpG}} "Bismark methylation extractor version $version\n";

      $cpg_ctot =~ s/^/CpG_CTOT_/;
      open ($fhs{1}->{CpG},'>',$cpg_ctot) or die "Failed to write to $cpg_ctot $!\n";
      print "Writing result file containing methylation information for C in CpG context from the complementary to original top strand to $cpg_ctot\n";
      print {$fhs{1}->{CpG}} "Bismark methylation extractor version $version\n";

      $cpg_ctob =~ s/^/CpG_CTOB_/;
      open ($fhs{2}->{CpG},'>',$cpg_ctob) or die "Failed to write to $cpg_ctob $!\n";
      print "Writing result file containing methylation information for C in CpG context from the complementary to original bottom strand to $cpg_ctob\n";
      print {$fhs{2}->{CpG}}  "Bismark methylation extractor version $version\n";

      $cpg_ob =~ s/^/CpG_OB_/;
      open ($fhs{3}->{CpG},'>',$cpg_ob) or die "Failed to write to $cpg_ob $!\n";
      print "Writing result file containing methylation information for C in CpG context from the original bottom strand to $cpg_ob\n\n";
      print {$fhs{3}->{CpG}}  "Bismark methylation extractor version $version\n";

      ### For cytosines in Non-CpG (CC, CT or CA) context
      my $other_c_ot = my $other_c_ctot = my $other_c_ctob = my $other_c_ob = $output_filename;

      $other_c_ot =~ s/^/Non_CpG_OT_/;
      open ($fhs{0}->{other_c},'>',$other_c_ot) or die "Failed to write to $other_c_ot $!\n";
      print "Writing result file containing methylation information for C in any other context from the original top strand to $other_c_ot\n";
      print {$fhs{0}->{other_c}} "Bismark methylation extractor version $version\n";

      $other_c_ctot =~ s/^/Non_CpG_CTOT_/;
      open ($fhs{1}->{other_c},'>',$other_c_ctot) or die "Failed to write to $other_c_ctot $!\n";
      print "Writing result file containing methylation information for C in any other context from the complementary to original top strand to $other_c_ctot\n";
      print {$fhs{1}->{other_c}} "Bismark methylation extractor version $version\n";

      $other_c_ctob =~ s/^/Non_CpG_CTOB_/;
      open ($fhs{2}->{other_c},'>',$other_c_ctob) or die "Failed to write to $other_c_ctob $!\n";
      print "Writing result file containing methylation information for C in any other context from the complementary to original bottom strand to $other_c_ctob\n";
      print {$fhs{2}->{other_c}} "Bismark methylation extractor version $version\n";

      $other_c_ob =~ s/^/Non_CpG_OB_/;
      open ($fhs{3}->{other_c},'>',$other_c_ob) or die "Failed to write to $other_c_ob $!\n";
      print "Writing result file containing methylation information for C in any other context from the original bottom strand to $other_c_ob\n\n";
      print {$fhs{3}->{other_c}} "Bismark methylation extractor version $version\n";
    }

    ### THIS SECTION IS THE DEFAULT (CpG, CHG and CHH context)

    ### if --comprehensive was specified we are only writing one file per context
    elsif ($full){
      my $cpg_output = my $chg_output =  my $chh_output = $output_filename;
      ### C in CpG context
      $cpg_output =~ s/^/CpG_context_/;
      open ($fhs{CpG_context},'>',$cpg_output) or die "Failed to write to $cpg_output $! \n";
      print "Writing result file containing methylation information for C in CpG context to $cpg_output\n";
      print {$fhs{CpG_context}} "Bismark methylation extractor version $version\n";

      ### C in CHG context
      $chg_output =~ s/^/CHG_context_/;
      open ($fhs{CHG_context},'>',$chg_output) or die "Failed to write to $chg_output $!\n";
      print "Writing result file containing methylation information for C in CHG context to $chg_output\n";
      print {$fhs{CHG_context}} "Bismark methylation extractor version $version\n";

      ### C in CHH context
      $chh_output =~ s/^/CHH_context_/;
      open ($fhs{CHH_context},'>',$chh_output) or die "Failed to write to $chh_output $!\n";
      print "Writing result file containing methylation information for C in CHH context to $chh_output\n";
      print {$fhs{CHH_context}} "Bismark methylation extractor version $version\n";   }

    ### else we will write out 12 different output files, depending on where the (first) unique best alignment was found
    else{
      my $cpg_ot = my $cpg_ctot = my $cpg_ctob = my $cpg_ob = $output_filename;

      ### For cytosines in CpG context
      $cpg_ot =~ s/^/CpG_OT_/;
      open ($fhs{0}->{CpG},'>',$cpg_ot) or die "Failed to write to $cpg_ot $!\n";
      print "Writing result file containing methylation information for C in CpG context from the original top strand to $cpg_ot\n";
      print {$fhs{0}->{CpG}} "Bismark methylation extractor version $version\n";

      $cpg_ctot =~ s/^/CpG_CTOT_/;
      open ($fhs{1}->{CpG},'>',$cpg_ctot) or die "Failed to write to $cpg_ctot $!\n";
      print "Writing result file containing methylation information for C in CpG context from the complementary to original top strand to $cpg_ctot\n";
      print {$fhs{1}->{CpG}} "Bismark methylation extractor version $version\n";

      $cpg_ctob =~ s/^/CpG_CTOB_/;
      open ($fhs{2}->{CpG},'>',$cpg_ctob) or die "Failed to write to $cpg_ctob $!\n";
      print "Writing result file containing methylation information for C in CpG context from the complementary to original bottom strand to $cpg_ctob\n";
      print {$fhs{2}->{CpG}}  "Bismark methylation extractor version $version\n";

      $cpg_ob =~ s/^/CpG_OB_/;
      open ($fhs{3}->{CpG},'>',$cpg_ob) or die "Failed to write to $cpg_ob $!\n";
      print "Writing result file containing methylation information for C in CpG context from the original bottom strand to $cpg_ob\n\n";
      print {$fhs{3}->{CpG}}  "Bismark methylation extractor version $version\n";

      ### For cytosines in CHG context
      my $chg_ot = my $chg_ctot = my $chg_ctob = my $chg_ob = $output_filename;

      $chg_ot =~ s/^/CHG_OT_/;
      open ($fhs{0}->{CHG},'>',$chg_ot) or die "Failed to write to $chg_ot $!\n";
      print "Writing result file containing methylation information for C in CHG context from the original top strand to $chg_ot\n";
      print {$fhs{0}->{CHG}} "Bismark methylation extractor version $version\n";

      $chg_ctot =~ s/^/CHG_CTOT_/;
      open ($fhs{1}->{CHG},'>',$chg_ctot) or die "Failed to write to $chg_ctot $!\n";
      print "Writing result file containing methylation information for C in CHG context from the complementary to original top strand to $chg_ctot\n";
      print {$fhs{1}->{CHG}} "Bismark methylation extractor version $version\n";

      $chg_ctob =~ s/^/CHG_CTOB_/;
      open ($fhs{2}->{CHG},'>',$chg_ctob) or die "Failed to write to $chg_ctob $!\n";
      print "Writing result file containing methylation information for C in CHG context from the complementary to original bottom strand to $chg_ctob\n";
      print {$fhs{2}->{CHG}} "Bismark methylation extractor version $version\n";

      $chg_ob =~ s/^/CHG_OB_/;
      open ($fhs{3}->{CHG},'>',$chg_ob) or die "Failed to write to $chg_ob $!\n";
      print "Writing result file containing methylation information for C in CHG context from the original bottom strand to $chg_ob\n\n";
      print {$fhs{3}->{CHG}} "Bismark methylation extractor version $version\n";

      ### For cytosines in CHH context
      my $chh_ot = my $chh_ctot = my $chh_ctob = my $chh_ob = $output_filename;

      $chh_ot =~ s/^/CHH_OT_/;
      open ($fhs{0}->{CHH},'>',$chh_ot) or die "Failed to write to $chh_ot $!\n";
      print "Writing result file containing methylation information for C in CHH context from the original top strand to $chh_ot\n";
      print {$fhs{0}->{CHH}} "Bismark methylation extractor version $version\n";

      $chh_ctot =~ s/^/CHH_CTOT_/;
      open ($fhs{1}->{CHH},'>',$chh_ctot) or die "Failed to write to $chh_ctot $!\n";
      print "Writing result file containing methylation information for C in CHH context from the complementary to original top strand to $chh_ctot\n";
      print {$fhs{1}->{CHH}} "Bismark methylation extractor version $version\n";

      $chh_ctob =~ s/^/CHH_CTOB_/;
      open ($fhs{2}->{CHH},'>',$chh_ctob) or die "Failed to write to $chh_ctob $!\n";
      print "Writing result file containing methylation information for C in CHH context from the complementary to original bottom strand to $chh_ctob\n";
      print {$fhs{2}->{CHH}} "Bismark methylation extractor version $version\n";

      $chh_ob =~ s/^/CHH_OB_/;
      open ($fhs{3}->{CHH},'>',$chh_ob) or die "Failed to write to $chh_ob $!\n";
      print "Writing result file containing methylation information for C in CHH context from the original bottom strand to $chh_ob\n\n";
      print {$fhs{3}->{CHH}} "Bismark methylation extractor version $version\n";
    }

    my $methylation_call_strings_processed = 0;
    my $line_count = 0;

    ### proceeding differently now for single-end or paired-end Bismark files

    ### PROCESSING SINGLE-END RESULT FILES
    if ($single){

      ### also proceeding differently now for SAM format or vanilla Bismark format files
      if ($vanilla){ # old vanilla Bismark output format
	while (<IN>){
	  ++$line_count;
	  warn "Processed lines: $line_count\n" if ($line_count%500000==0);
	
	  ### $seq here is the chromosomal sequence (to use for the repeat analysis for example)
	  my ($id,$strand,$chrom,$start,$seq,$meth_call,$read_conversion,$genome_conversion) = (split("\t"))[0,1,2,3,6,7,8,9];
	
	  ### we need to remove 2 bp of the genomic sequence as we were extracting read + 2bp long fragments to make a methylation call at the first or
	  ### last position
	  chomp $genome_conversion;

	  my $index;
	  if ($meth_call){

	    if ($read_conversion eq 'CT' and $genome_conversion eq 'CT'){ ## original top strand
	      $index = 0;
	    }	
	    elsif ($read_conversion eq 'GA' and $genome_conversion eq 'CT'){ ## complementary to original top strand
	      $index = 1;
	    }
	    elsif ($read_conversion eq 'CT' and $genome_conversion eq 'GA'){ ## original bottom strand
	      $index = 3;
	    }
	    elsif ($read_conversion eq 'GA' and $genome_conversion eq 'GA'){ ## complementary to original bottom strand
	      $index = 2;
	    }
	    else {
	      die "Unexpected combination of read and genome conversion: $read_conversion / $genome_conversion\n";
	    }
	
	    ### We will need to discriminate between 2 extra bases at the 5' end or at the 3' end
	    ### removing most 3' bases  ### As of Bismark version 0.6.x this option is no longer supported
	    #    if ($read_conversion =~ /^CT/){
	    #      $seq = substr($seq,0,length($seq)-2);
	    #    }	
	    ### removing most 5' bases
	    #    elsif ($read_conversion =~ /^GA/){
	    #      $seq = substr($seq,2,length($seq)-2);
	    #    }
	    #   else{
	    #     die "We need the read conversion info to proceed with extracting the correct part of the genomic sequence\n";
	    #   }

	    ### Clipping off the first <int> number of bases from the methylation call string as specified with --ignore <int>
	    if ($ignore){
	      $meth_call = substr($meth_call,$ignore,length($meth_call)-$ignore);	
	
	      ### If we are clipping off some bases at the start we need to adjust the start position of the alignments accordingly!
	      if ($strand eq '+'){
		$start += $ignore;
	      }
	      elsif ($strand eq '-'){
		$start += length($meth_call)-1; ## $meth_call is already shortened!
	      }
	      else {
		die "Alignment did not have proper strand information: $strand\n";
	      }
	    }
	    ### printing out the methylation state of every C in the read
	    print_individual_C_methylation_states_single_end($meth_call,$chrom,$start,$id,$strand,$index);
	
	    ++$methylation_call_strings_processed; # 1 per single-end result
	  }
	}
      }
      else{ # processing single-end SAM format (default)
	while (<IN>){
	  ### SAM format can either start with header lines (starting with @) or start with alignments directly
	  if (/^\@/){ # skipping header lines (starting with @)
	    warn "skipping SAM header line:\t$_";
	    next;
	  }

	  ++$line_count;
	  warn "Processed lines: $line_count\n" if ($line_count%500000==0);
	
	  # example read in SAM format
	  # 1_R1/1	67	5	103172224	255	40M	=	103172417	233	AATATTTTTTTTATTTTAAAATGTGTATTGATTTAAATTT	IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII	NM:i:4	XX:Z:4T1T24TT7	XM:Z:....h.h........................hh.......	XR:Z:CT	XG:Z:CT
	  ###
	  my ($id,$chrom,$start,$meth_call,$read_conversion,$genome_conversion) = (split("\t"))[0,2,3,13,14,15];
	  $meth_call =~ s/^XM:Z://;
	  $read_conversion =~ s/^XR:Z://;
	  $genome_conversion =~ s/^XG:Z://;	
	  my $strand;
	  chomp $genome_conversion;
	  # print "$meth_call\n$read_conversion\n$genome_conversion\n";
	
	  my $index;
	  if ($meth_call){
	    if ($read_conversion eq 'CT' and $genome_conversion eq 'CT'){ ## original top strand
	      $index = 0;
	      $strand = '+';
	    }	
	    elsif ($read_conversion eq 'GA' and $genome_conversion eq 'CT'){ ## complementary to original top strand
	      $index = 1;
	      $strand = '-';
	    }
	    elsif ($read_conversion eq 'GA' and $genome_conversion eq 'GA'){ ## complementary to original bottom strand
	      $index = 2;
	      $strand = '+';
	    }
	    elsif ($read_conversion eq 'CT' and $genome_conversion eq 'GA'){ ## original bottom strand
	      $index = 3;
	      $strand = '-';
	    }
	    else {
	      die "Unexpected combination of read and genome conversion: $read_conversion / $genome_conversion\n";
	    }
	
	    ### If the read is in SAM format we need to reverse the methylation call if the read has been reverse-complemented for the output
	    if ($strand eq '-'){
	      $meth_call = reverse $meth_call;
	    }
	
	    ### Clipping off the first <int> number of bases from the methylation call string as specified with --ignore <int>
	    if ($ignore){
	      $meth_call = substr($meth_call,$ignore,length($meth_call)-$ignore);	
	
	      ### If we are clipping off some bases at the start we need to adjust the start position of the alignments accordingly!
	      if ($strand eq '+'){
		$start += $ignore;
	      }
	      elsif ($strand eq '-'){
		$start += length($meth_call)-1; ## $meth_call is already shortened! Passing on the start position on the reverse strand
	      }
	    }
	  }
	  ### printing out the methylation state of every C in the read
	  print_individual_C_methylation_states_single_end($meth_call,$chrom,$start,$id,$strand,$index);
	
	  ++$methylation_call_strings_processed; # 1 per single-end result
	}
      }
    }

    ### PROCESSING PAIRED-END RESULT FILES
    elsif ($paired){

      ### proceeding differently now for SAM format or vanilla Bismark format files
      if ($vanilla){ # old vanilla Bismark paired-end output format
	while (<IN>){
	  ++$line_count;
	  warn "processed line: $line_count\n" if ($line_count%500000==0);

	  ### $seq here is the chromosomal sequence (to use for the repeat analysis for example)
	  my ($id,$strand,$chrom,$start_read_1,$end_read_2,$seq_1,$meth_call_1,$seq_2,$meth_call_2,$first_read_conversion,$genome_conversion) = (split("\t"))[0,1,2,3,4,6,7,9,10,11,12,13];

	  my $index;
	  chomp $genome_conversion;
	
	  if ($first_read_conversion eq 'CT' and $genome_conversion eq 'CT'){
	    $index = 0; ## this is OT
	  }	
	  elsif ($first_read_conversion eq 'GA' and $genome_conversion eq 'GA'){
	    $index = 2; ## this is CTOB!!!
	  }
	  elsif ($first_read_conversion eq 'GA' and $genome_conversion eq 'CT'){
	    $index = 1; ## this is CTOT!!!
	  }
	  elsif ($first_read_conversion eq 'CT' and $genome_conversion eq 'GA'){
	    $index = 3; ## this is OB
	  }
	  else {
	    die "Unexpected combination of read and genome conversion: $first_read_conversion / $genome_conversion\n";
	  }
	
	  ### we need to remove 2 bp of the genomic sequence as we were extracting read + 2bp long fragments to make a methylation call at the
	  ### first or last position ### This is no longer needed/supported as of Bismark version 0.6.x
	  # if ($index == 0 or $index == 2){
	  #	    $seq_1 = substr($seq_1,0,length($seq_1)-2);
	  #	    $seq_2 = substr($seq_2,2,length($seq_2)-2);
	  #	  }
	  #	  else{
	  #	    $seq_1 = substr($seq_1,2,length($seq_1)-2);
	  #	    $seq_2 = substr($seq_2,0,length($seq_2)-2);
	  #	  }
	
	  if ($meth_call_1 and $meth_call_2){
	    ### Clipping off the first <int> number of bases from the methylation call strings as specified with '--ignore <int>'
	    if ($ignore){
	      $meth_call_1 = substr($meth_call_1,$ignore,length($meth_call_1)-$ignore);
	      $meth_call_2 = substr($meth_call_2,$ignore,length($meth_call_2)-$ignore);

	      ### we also need to adjust the start and end positions of the alignments accordingly if '--ignore' was specified
	      $start_read_1 += $ignore;
	      $end_read_2   -= $ignore;
	    }
	
	    my $end_read_1 = $start_read_1+length($meth_call_1)-1;
	    my $start_read_2 = $end_read_2-length($meth_call_2)+1;
	
	    if ($strand eq '+'){
	      ## we first pass the first read which is in + orientation on the forward strand
	      print_individual_C_methylation_states_paired_end_files($meth_call_1,$chrom,$start_read_1,$id,'+',$index,0,0);
	
	      # we next pass the second read which is in - orientation on the reverse strand
	      ### if --no_overlap was specified we also pass the end of read 1. If read 2 starts to overlap with read 1 we can stop extracting methylation calls from read 2
	      print_individual_C_methylation_states_paired_end_files($meth_call_2,$chrom,$end_read_2,$id,'-',$index,$no_overlap,$end_read_1);
	    }
	
	    else{
	      ## we first pass the first read which is in - orientation on the reverse strand
	      print_individual_C_methylation_states_paired_end_files($meth_call_1,$chrom,$end_read_2,$id,'-',$index,0,0);

	      # we next pass the second read which is in + orientation on the forward strand
	      ### if --no_overlap was specified we also pass the end of read 2. If read 2 starts to overlap with read 1 we will stop extracting methylation calls from read 2
	      print_individual_C_methylation_states_paired_end_files($meth_call_2,$chrom,$start_read_1,$id,'+',$index,$no_overlap,$start_read_2);
	    }
	
	    $methylation_call_strings_processed += 2; # paired-end = 2 methylation calls
	  }	
	}
      }
      else{ # Bismark paired-end SAM output format (default)
	while (<IN>){
	  ### SAM format can either start with header lines (starting with @) or start with alignments directly
	  if (/^\@/){ # skipping header lines (starting with @)
	    warn "skipping SAM header line:\t$_";
	    next;
	  }
	
	  ++$line_count;
	  warn "Processed lines: $line_count\n" if ($line_count%500000==0);
	
	  # example paired-end reads in SAM format (2 consecutive lines)
	  # 1_R1/1	67	5	103172224	255	40M	=	103172417	233	AATATTTTTTTTATTTTAAAATGTGTATTGATTTAAATTT	IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII	NM:i:4	XX:Z:4T1T24TT7	XM:Z:....h.h........................hh.......	XR:Z:CT	XG:Z:CT
	  # 1_R1/2	131	5	103172417	255	40M	=	103172224	-233	TATTTTTTTTTAGAGTATTTTTTAATGGTTATTAGATTTT	IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII	NM:i:6	XX:Z:T5T1T9T9T7T3	XM:Z:h.....h.h.........h.........h.......h...	XR:Z:GA	XG:Z:CT
	
	  my ($id_1,$chrom,$start_read_1,$meth_call_1,$first_read_conversion,$genome_conversion) = (split("\t"))[0,2,3,13,14,15];
	  $_ = <IN>; # reading in the paired read
	  my ($id_2,$start_read_2,$meth_call_2,$second_read_conversion) = (split("\t"))[0,3,13,14];
	  $meth_call_1 =~ s/^XM:Z://;
	  $meth_call_2 =~ s/^XM:Z://;
	  $first_read_conversion =~ s/^XR:Z://;
	  $second_read_conversion =~ s/^XR:Z://;
	  $genome_conversion =~ s/^XG:Z://;	
	  chomp $genome_conversion;	
	  # print join ("\t",$meth_call_1,$meth_call_2,$first_read_conversion,$second_read_conversion,$genome_conversion),"\n";

	  my $index;
	  my $strand;

	  if ($first_read_conversion eq 'CT' and $genome_conversion eq 'CT'){
	    $index = 0; ## this is OT
	    $strand = '+';
	  }	
	  elsif ($first_read_conversion eq 'GA' and $genome_conversion eq 'CT'){
	    $index = 1; ## this is CTOT
	    $strand = '-';
	  }
	  elsif ($first_read_conversion eq 'GA' and $genome_conversion eq 'GA'){
	    $index = 2; ## this is CTOB
	    $strand = '+';
	  }
	  elsif ($first_read_conversion eq 'CT' and $genome_conversion eq 'GA'){
	    $index = 3; ## this is OB
	    $strand = '-';
	  }
	  else {
	    die "Unexpected combination of read and genome conversion: $first_read_conversion / $genome_conversion\n";
	  }

	  ### reversing the methylation call of the read that was reverse-complemented
	  if ($strand eq '+'){
	    $meth_call_2 = reverse $meth_call_2;
	  }
	  else{
	    $meth_call_1 = reverse $meth_call_1;
	  }

	  if ($meth_call_1 and $meth_call_2){
	    ### Clipping off the first <int> number of bases from the methylation call strings as specified with '--ignore <int>'
	    my $end_read_1;
	
	    if ($ignore){
	      $meth_call_1 = substr($meth_call_1,$ignore,length($meth_call_1)-$ignore);
	      $meth_call_2 = substr($meth_call_2,$ignore,length($meth_call_2)-$ignore);

	      ### If we are clipping off some bases at the start we need to adjust the start position of the alignments accordingly!
	      if ($strand eq '+'){
		$start_read_1 += $ignore;
	      }
	      elsif ($strand eq '-'){
		$start_read_2 += $ignore;
	      }

	      #    $end_read_1 = $start_read_1+length($meth_call_1)-1;
	      #    my $start_read_2 = $end_read_2-length($meth_call_2)+1;
	      #    ### we also need to adjust the start and end positions of the alignments accordingly if '--ignore' was specified
	      #    $start_1 += $ignore;
	      #    $end_read_2   -= $ignore;
	    }
	    if ($strand eq '+'){
	      $end_read_1 = $start_read_1+length($meth_call_1)-1;
	      $start_read_2 += length($meth_call_2)-1; ## $meth_call_2 is already shortened! Passing on the start position on the reverse strand
	    }
	    else{
	      $end_read_1 = $start_read_1;	
	      $start_read_1 += length($meth_call_1)-1; ## $meth_call_1 is already shortened! Passing on the start position on the reverse strand
	    }

	    if ($strand eq '+'){
	      ## we first pass the first read which is in + orientation on the forward strand
	      print_individual_C_methylation_states_paired_end_files($meth_call_1,$chrom,$start_read_1,$id_1,'+',$index,0,0);
	
	      # we next pass the second read which is in - orientation on the reverse strand
	      ### if --no_overlap was specified we also pass the end of read 1. If read 2 starts to overlap with read 1 we can stop extracting methylation calls from read 2
	      print_individual_C_methylation_states_paired_end_files($meth_call_2,$chrom,$start_read_2,$id_2,'-',$index,$no_overlap,$end_read_1);
	    }
	
	    else{
	      ## we first pass the first read which is in - orientation on the reverse strand
	      print_individual_C_methylation_states_paired_end_files($meth_call_1,$chrom,$start_read_1,$id_1,'-',$index,0,0);
	
	      # we next pass the second read which is in + orientation on the forward strand
	      ### if --no_overlap was specified we also pass the end of read 1. If read 2 starts to overlap with read 1 we will stop extracting methylation calls from read 2
	      print_individual_C_methylation_states_paired_end_files($meth_call_2,$chrom,$start_read_2,$id_2,'+',$index,$no_overlap,$end_read_1);
	    }
	
	    $methylation_call_strings_processed += 2; # paired-end = 2 methylation calls
	  }	
	}
      }
    }
    else{
      die "Single-end or paired-end reads not specified properly\n";
    }

    print "\n\nProcessed $line_count lines from $filename in total\n";
    print "Total number of methylation call strings processed: $methylation_call_strings_processed\n\n";
    if ($report){
      print REPORT "Total number of methylation call strings processed: $methylation_call_strings_processed\n\n";
    }
    print_splitting_report ();
  }
}


sub print_splitting_report{

  ### Calculating methylation percentages if applicable

  my $percent_meCpG;
  if (($counting{total_meCpG_count}+$counting{total_unmethylated_CpG_count}) > 0){
    $percent_meCpG = sprintf("%.1f",100*$counting{total_meCpG_count}/($counting{total_meCpG_count}+$counting{total_unmethylated_CpG_count}));
  }

  my $percent_meCHG;
  if (($counting{total_meCHG_count}+$counting{total_unmethylated_CHG_count}) > 0){
    $percent_meCHG = sprintf("%.1f",100*$counting{total_meCHG_count}/($counting{total_meCHG_count}+$counting{total_unmethylated_CHG_count}));
  }

  my $percent_meCHH;
  if (($counting{total_meCHH_count}+$counting{total_unmethylated_CHH_count}) > 0){
    $percent_meCHH = sprintf("%.1f",100*$counting{total_meCHH_count}/($counting{total_meCHH_count}+$counting{total_unmethylated_CHH_count}));
  }

  my $percent_non_CpG_methylation;
  if ($merge_non_CpG){
    if ( ($counting{total_meCHH_count}+$counting{total_unmethylated_CHH_count}+$counting{total_meCHG_count}+$counting{total_unmethylated_CHG_count}) > 0){
      $percent_non_CpG_methylation = sprintf("%.1f",100* ( $counting{total_meCHH_count}+$counting{total_meCHG_count} ) / ( $counting{total_meCHH_count}+$counting{total_unmethylated_CHH_count}+$counting{total_meCHG_count}+$counting{total_unmethylated_CHG_count} ) );
    }
  }

  if ($report){
    ### detailed information about Cs analysed
    print REPORT "Final Cytosine Methylation Report\n",'='x33,"\n";

    my $total_number_of_C = $counting{total_meCHG_count}+$counting{total_meCHH_count}+$counting{total_meCpG_count}+$counting{total_unmethylated_CHG_count}+$counting{total_unmethylated_CHH_count}+$counting{total_unmethylated_CpG_count};
    print REPORT "Total number of C's analysed:\t$total_number_of_C\n\n";

    print REPORT "Total methylated C's in CpG context:\t$counting{total_meCpG_count}\n";
    print REPORT "Total methylated C's in CHG context:\t$counting{total_meCHG_count}\n";
    print REPORT "Total methylated C's in CHH context:\t$counting{total_meCHH_count}\n\n";

    print REPORT "Total C to T conversions in CpG context:\t$counting{total_unmethylated_CpG_count}\n";
    print REPORT "Total C to T conversions in CHG context:\t$counting{total_unmethylated_CHG_count}\n";
    print REPORT "Total C to T conversions in CHH context:\t$counting{total_unmethylated_CHH_count}\n\n";

    ### calculating methylated CpG percentage if applicable
    if ($percent_meCpG){
      print REPORT "C methylated in CpG context:\t${percent_meCpG}%\n";
    }
    else{
      print REPORT "Can't determine percentage of methylated Cs in CpG context if value was 0\n";
    }

    ### 2-Context Output
    if ($merge_non_CpG){
      if ($percent_non_CpG_methylation){
	print REPORT "C methylated in non-CpG context:\t${percent_non_CpG_methylation}%\n\n\n";
      }
      else{
	print REPORT "Can't determine percentage of methylated Cs in non-CpG context if value was 0\n\n\n";
      }
    }

    ### 3 Context Output
    else{
      ### calculating methylated CHG percentage if applicable
      if ($percent_meCHG){
	print REPORT "C methylated in CHG context:\t${percent_meCHG}%\n";
      }
      else{
	print REPORT "Can't determine percentage of methylated Cs in CHG context if value was 0\n";
      }

      ### calculating methylated CHH percentage if applicable
      if ($percent_meCHH){
	print REPORT "C methylated in CHH context:\t${percent_meCHH}%\n\n\n";
      }
      else{
	print REPORT "Can't determine percentage of methylated Cs in CHH context if value was 0\n\n\n";
      }
    }
  }

  ### detailed information about Cs analysed for on-screen report
  print "Final Cytosine Methylation Report\n",'='x33,"\n";

  my $total_number_of_C = $counting{total_meCHG_count}+$counting{total_meCHH_count}+$counting{total_meCpG_count}+$counting{total_unmethylated_CHG_count}+$counting{total_unmethylated_CHH_count}+$counting{total_unmethylated_CpG_count};
  print "Total number of C's analysed:\t$total_number_of_C\n\n";

  print "Total methylated C's in CpG context:\t$counting{total_meCpG_count}\n";
  print "Total methylated C's in CHG context:\t$counting{total_meCHG_count}\n";
  print "Total methylated C's in CHH context:\t$counting{total_meCHH_count}\n\n";

  print "Total C to T conversions in CpG context:\t$counting{total_unmethylated_CpG_count}\n";
  print "Total C to T conversions in CHG context:\t$counting{total_unmethylated_CHG_count}\n";
  print "Total C to T conversions in CHH context:\t$counting{total_unmethylated_CHH_count}\n\n";

  ### printing methylated CpG percentage if applicable
  if ($percent_meCpG){
    print "C methylated in CpG context:\t${percent_meCpG}%\n";
  }
  else{
    print "Can't determine percentage of methylated Cs in CpG context if value was 0\n";
  }

  ### 2-Context Output
  if ($merge_non_CpG){
    if ($percent_non_CpG_methylation){
      print "C methylated in non-CpG context:\t${percent_non_CpG_methylation}%\n\n\n";
    }
    else{
      print "Can't determine percentage of methylated Cs in non-CpG context if value was 0\n\n\n";
    }
  }

  ### 3-Context Output
  else{
    ### printing methylated CHG percentage if applicable
    if ($percent_meCHG){
      print "C methylated in CHG context:\t${percent_meCHG}%\n";
    }
    else{
      print "Can't determine percentage of methylated Cs in CHG context if value was 0\n";
    }

    ### printing methylated CHH percentage if applicable
    if ($percent_meCHH){
      print "C methylated in CHH context:\t${percent_meCHH}%\n\n\n";
    }
    else{
      print "Can't determine percentage of methylated Cs in CHH context if value was 0\n\n\n";
    }
  }
}

sub print_individual_C_methylation_states_paired_end_files{

  my ($meth_call,$chrom,$start,$id,$strand,$filehandle_index,$no_overlap,$end_read_1) = @_;
  my @methylation_calls = split(//,$meth_call);

  #################################################################
  ### . for bases not involving cytosines                       ###
  ### X for methylated C in CHG context (was protected)         ###
  ### x for not methylated C in CHG context (was converted)     ###
  ### H for methylated C in CHH context (was protected)         ###
  ### h for not methylated C in CHH context (was converted)     ###
  ### Z for methylated C in CpG context (was protected)         ###
  ### z for not methylated C in CpG context (was converted)     ###
  #################################################################

  my $methyl_CHG_count = 0;
  my $methyl_CHH_count = 0;
  my $methyl_CpG_count = 0;
  my $unmethylated_CHG_count = 0;
  my $unmethylated_CHH_count = 0;
  my $unmethylated_CpG_count = 0;

  ### THIS IS AN OPTIONAL 2-CONTEXT (CpG and non-CpG) SECTION IF --merge_non_CpG was specified

  if ($merge_non_CpG) {

    if ($no_overlap) {

      ### single-file CpG and non-CpG context output
      if ($full) {
	if ($strand eq '+') {
	  for my $index (0..$#methylation_calls) {
	
	    ### Returning as soon as the methylation calls start overlapping
	    if ($start+$index >= $end_read_1) {
	      return;
	    }
	
	    if ($methylation_calls[$index] eq 'X') {
	      $counting{total_meCHG_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'x') {
	      $counting{total_unmethylated_CHG_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'Z') {
	      $counting{total_meCpG_count}++;
	      print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'z') {
	      $counting{total_unmethylated_CpG_count}++;
	      print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'H') {
	      $counting{total_meCHH_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'h') {
	      $counting{total_unmethylated_CHH_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    }
	    elsif ($methylation_calls[$index] eq '.'){}
	    else{
	      die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	    }
	  }
	} elsif ($strand eq '-') {
	  for my $index (0..$#methylation_calls) {
	
	    ### Returning as soon as the methylation calls start overlapping
	    if ($start-$index <= $end_read_1) {
	      return;
	    }

	    if ($methylation_calls[$index] eq 'X') {
	      $counting{total_meCHG_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'x') {
	      $counting{total_unmethylated_CHG_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'Z') {
	      $counting{total_meCpG_count}++;
	      print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'z') {
	      $counting{total_unmethylated_CpG_count}++;
	      print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'H') {
	      $counting{total_meCHH_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'h') {
	      $counting{total_unmethylated_CHH_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    }
	    elsif ($methylation_calls[$index] eq '.') {}
	    else{
	      die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	    }
	  }
	} else {
	  die "This cannot happen $!\n";
	}
      }

      ### strand-specific methylation output
      else {
	if ($strand eq '+') {
	  for my $index (0..$#methylation_calls) {

	    ### Returning as soon as the methylation calls start overlapping
	    if ($start+$index >= $end_read_1) {
	      return;
	    }

	    if ($methylation_calls[$index] eq 'X') {
	      $counting{total_meCHG_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'x') {
	      $counting{total_unmethylated_CHG_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'Z') {
	      $counting{total_meCpG_count}++;
	      print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'z') {
	      $counting{total_unmethylated_CpG_count}++;
	      print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'H') {
	      $counting{total_meCHH_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'h') {
	      $counting{total_unmethylated_CHH_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    }
	    elsif ($methylation_calls[$index] eq '.') {}
	    else{
	      die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	    }	
	  }
	} elsif ($strand eq '-') {
	  for my $index (0..$#methylation_calls) {

	    ### Returning as soon as the methylation calls start overlapping
	    if ($start-$index <= $end_read_1) {
	      return;
	    }
	
	    if ($methylation_calls[$index] eq 'X') {
	      $counting{total_meCHG_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'x') {
	      $counting{total_unmethylated_CHG_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'Z') {
	      $counting{total_meCpG_count}++;
	      print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'z') {
	      $counting{total_unmethylated_CpG_count}++;
	      print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'H') {
	      $counting{total_meCHH_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'h') {
	      $counting{total_unmethylated_CHH_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    }
	    elsif ($methylation_calls[$index] eq '.') {}
	    else{
	      die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	    }
	  }
	} else {
	  die "This cannot happen $!\n";
	}
      }
    }

    ### this is the default paired-end procedure allowing overlaps and using every single C position
    ### Still within the 2-CONTEXT ONLY optional section
    else {
      ### single-file CpG and non-CpG context output
      if ($full) {
	if ($strand eq '+') {
	  for my $index (0..$#methylation_calls) {
	    if ($methylation_calls[$index] eq 'X') {
	      $counting{total_meCHG_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'x') {
	      $counting{total_unmethylated_CHG_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'Z') {
	      $counting{total_meCpG_count}++;
	      print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'z') {
	      $counting{total_unmethylated_CpG_count}++;
	      print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'H') {
	      $counting{total_meCHH_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'h') {
	      $counting{total_unmethylated_CHH_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    }
	    elsif ($methylation_calls[$index] eq '.') {}
	    else{
	      die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	    }
	  }
	} elsif ($strand eq '-') {
	  for my $index (0..$#methylation_calls) {
	    if ($methylation_calls[$index] eq 'X') {
	      $counting{total_meCHG_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'x') {
	      $counting{total_unmethylated_CHG_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'Z') {
	      $counting{total_meCpG_count}++;
	      print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'z') {
	      $counting{total_unmethylated_CpG_count}++;
	      print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'H') {
	      $counting{total_meCHH_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'h') {
	      $counting{total_unmethylated_CHH_count}++;
	      print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    }
	    elsif ($methylation_calls[$index] eq '.') {}
	    else{
	      die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	    }
	  }
	} else {
	  die "This cannot happen $!\n";
	}
      }

      ### strand-specific methylation output
      ### still within the 2-CONTEXT optional section
      else {
	if ($strand eq '+') {
	  for my $index (0..$#methylation_calls) {
	    if ($methylation_calls[$index] eq 'X') {
	      $counting{total_meCHG_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'x') {
	      $counting{total_unmethylated_CHG_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'Z') {
	      $counting{total_meCpG_count}++;
	      print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'z') {
	      $counting{total_unmethylated_CpG_count}++;
	      print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'H') {
	      $counting{total_meCHH_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'h') {
	      $counting{total_unmethylated_CHH_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	    }
	    elsif ($methylation_calls[$index] eq '.') {}
	    else{
	      die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	    }
	  }
	} elsif ($strand eq '-') {
	  for my $index (0..$#methylation_calls) {
	    if ($methylation_calls[$index] eq 'X') {
	      $counting{total_meCHG_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'x') {
	      $counting{total_unmethylated_CHG_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'Z') {
	      $counting{total_meCpG_count}++;
	      print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'z') {
	      $counting{total_unmethylated_CpG_count}++;
	      print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'H') {
	      $counting{total_meCHH_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    } elsif ($methylation_calls[$index] eq 'h') {
	      $counting{total_unmethylated_CHH_count}++;
	      print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	    }
	    elsif ($methylation_calls[$index] eq '.') {}
	    else{
	      die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	    }
	  }
	} else {
	  die "This cannot happen $!\n";
	}
      }
    }
  }

  ############################################
  ### THIS IS THE DEFAULT 3-CONTEXT OUTPUT ###
  ############################################

  elsif ($no_overlap) {

    ### single-file CpG, CHG and CHH context output
    if ($full) {
      if ($strand eq '+') {
	for my $index (0..$#methylation_calls) {
	
	  ### Returning as soon as the methylation calls start overlapping
	  if ($start+$index >= $end_read_1) {
	    return;
	  }
	
	  if ($methylation_calls[$index] eq 'X') {
	    $counting{total_meCHG_count}++;
	    print {$fhs{CHG_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'x') {
	    $counting{total_unmethylated_CHG_count}++;
	    print {$fhs{CHG_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'Z') {
	    $counting{total_meCpG_count}++;
	    print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'z') {
	    $counting{total_unmethylated_CpG_count}++;
	    print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'H') {
	    $counting{total_meCHH_count}++;
	    print {$fhs{CHH_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'h') {
	    $counting{total_unmethylated_CHH_count}++;
	    print {$fhs{CHH_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  }
	  elsif ($methylation_calls[$index] eq '.') {}
	  else{
	    die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	  }
	}
      } elsif ($strand eq '-') {
	for my $index (0..$#methylation_calls) {

	  ### Returning as soon as the methylation calls start overlapping
	  if ($start-$index <= $end_read_1) {
	    return;
	  }

	  if ($methylation_calls[$index] eq 'X') {
	    $counting{total_meCHG_count}++;
	    print {$fhs{CHG_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'x') {
	    $counting{total_unmethylated_CHG_count}++;
	    print {$fhs{CHG_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'Z') {
	    $counting{total_meCpG_count}++;
	    print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'z') {
	    $counting{total_unmethylated_CpG_count}++;
	    print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'H') {
	    $counting{total_meCHH_count}++;
	    print {$fhs{CHH_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'h') {
	    $counting{total_unmethylated_CHH_count}++;
	    print {$fhs{CHH_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  }
	  elsif ($methylation_calls[$index] eq '.') {}
	  else{
	    die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	  }
	}
      } else {
	die "This cannot happen $!\n";
      }
    }

    ### strand-specific methylation output
    else {
      if ($strand eq '+') {
	for my $index (0..$#methylation_calls) {

	  ### Returning as soon as the methylation calls start overlapping
	  if ($start+$index >= $end_read_1) {
	    return;
	  }

	  if ($methylation_calls[$index] eq 'X') {
	    $counting{total_meCHG_count}++;
	    print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'x') {
	    $counting{total_unmethylated_CHG_count}++;
	    print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'Z') {
	    $counting{total_meCpG_count}++;
	    print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'z') {
	    $counting{total_unmethylated_CpG_count}++;
	    print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'H') {
	    $counting{total_meCHH_count}++;
	    print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'h') {
	    $counting{total_unmethylated_CHH_count}++;
	    print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  }
	  elsif ($methylation_calls[$index] eq '.') {}
	  else{
	    die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	  }	
	}
      } elsif ($strand eq '-') {
	for my $index (0..$#methylation_calls) {

	  ### Returning as soon as the methylation calls start overlapping
	  if ($start-$index <= $end_read_1) {
	    return;
	  }
	
	  if ($methylation_calls[$index] eq 'X') {
	    $counting{total_meCHG_count}++;
	    print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'x') {
	    $counting{total_unmethylated_CHG_count}++;
	    print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'Z') {
	    $counting{total_meCpG_count}++;
	    print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'z') {
	    $counting{total_unmethylated_CpG_count}++;
	    print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'H') {
	    $counting{total_meCHH_count}++;
	    print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'h') {
	    $counting{total_unmethylated_CHH_count}++;
	    print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  }
	  elsif ($methylation_calls[$index] eq '.') {}
	  else{
	    die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	  }
	}
      } else {
	die "This cannot happen $!\n";
      }
    }
  }

  ### this is the default paired-end procedure allowing overlaps and using every single C position
  else {
    ### single-file CpG, CHG and CHH context output
    if ($full) {
      if ($strand eq '+') {
	for my $index (0..$#methylation_calls) {
	  if ($methylation_calls[$index] eq 'X') {
	    $counting{total_meCHG_count}++;
	    print {$fhs{CHG_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'x') {
	    $counting{total_unmethylated_CHG_count}++;
	    print {$fhs{CHG_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'Z') {
	    $counting{total_meCpG_count}++;
	    print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'z') {
	    $counting{total_unmethylated_CpG_count}++;
	    print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'H') {
	    $counting{total_meCHH_count}++;
	    print {$fhs{CHH_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'h') {
	    $counting{total_unmethylated_CHH_count}++;
	    print {$fhs{CHH_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  }
	  elsif ($methylation_calls[$index] eq '.') {}
	  else{
	    die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	  }
	}
      } elsif ($strand eq '-') {
	for my $index (0..$#methylation_calls) {
	  if ($methylation_calls[$index] eq 'X') {
	    $counting{total_meCHG_count}++;
	    print {$fhs{CHG_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'x') {
	    $counting{total_unmethylated_CHG_count}++;
	    print {$fhs{CHG_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'Z') {
	    $counting{total_meCpG_count}++;
	    print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'z') {
	    $counting{total_unmethylated_CpG_count}++;
	    print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'H') {
	    $counting{total_meCHH_count}++;
	    print {$fhs{CHH_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'h') {
	    $counting{total_unmethylated_CHH_count}++;
	    print {$fhs{CHH_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  }
	  elsif ($methylation_calls[$index] eq '.') {}
	  else{
	    die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	  }
	}
      } else {
	die "This cannot happen $!\n";
      }
    }

    ### strand-specific methylation output
    else {
      if ($strand eq '+') {
	for my $index (0..$#methylation_calls) {
	  if ($methylation_calls[$index] eq 'X') {
	    $counting{total_meCHG_count}++;
	    print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'x') {
	    $counting{total_unmethylated_CHG_count}++;
	    print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'Z') {
	    $counting{total_meCpG_count}++;
	    print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'z') {
	    $counting{total_unmethylated_CpG_count}++;
	    print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'H') {
	    $counting{total_meCHH_count}++;
	    print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'h') {
	    $counting{total_unmethylated_CHH_count}++;
	    print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	  }
	  elsif ($methylation_calls[$index] eq '.') {}
	  else{
	    die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	  }
	}
      } elsif ($strand eq '-') {
	for my $index (0..$#methylation_calls) {
	  if ($methylation_calls[$index] eq 'X') {
	    $counting{total_meCHG_count}++;
	    print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'x') {
	    $counting{total_unmethylated_CHG_count}++;
	    print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'Z') {
	    $counting{total_meCpG_count}++;
	    print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'z') {
	    $counting{total_unmethylated_CpG_count}++;
	    print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'H') {
	    $counting{total_meCHH_count}++;
	    print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  } elsif ($methylation_calls[$index] eq 'h') {
	    $counting{total_unmethylated_CHH_count}++;
	    print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	  }
	  elsif ($methylation_calls[$index] eq '.') {}
	  else{
	    die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	  }
	}
      } else {
	die "This cannot happen $!\n";
      }
    }
  }
}


sub print_individual_C_methylation_states_single_end{

  my ($meth_call,$chrom,$start,$id,$strand,$filehandle_index) = @_;
  my @methylation_calls = split(//,$meth_call);

  #################################################################
  ### . for bases not involving cytosines                       ###
  ### X for methylated C in CHG context (was protected)         ###
  ### x for not methylated C in CHG context (was converted)     ###
  ### H for methylated C in CHH context (was protected)         ###
  ### h for not methylated C in CHH context (was converted)     ###
  ### Z for methylated C in CpG context (was protected)         ###
  ### z for not methylated C in CpG context (was converted)     ###
  #################################################################

  my $methyl_CHG_count = 0;
  my $methyl_CHH_count = 0;
  my $methyl_CpG_count = 0;
  my $unmethylated_CHG_count = 0;
  my $unmethylated_CHH_count = 0;
  my $unmethylated_CpG_count = 0;

  ### THIS IS THE CpG and Non-CpG SECTION (OPTIONAL)

### single-file CpG and other-context output
  if ($full and $merge_non_CpG) {
    if ($strand eq '+') {
      for my $index (0..$#methylation_calls) {
	### methylated Cs (any context) will receive a forward (+) orientation
	### not methylated Cs (any context) will receive a reverse (-) orientation
	if ($methylation_calls[$index] eq 'X') {
	  $counting{total_meCHG_count}++;
	  print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'x') {
	  $counting{total_unmethylated_CHG_count}++;
	  print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'Z') {
	  $counting{total_meCpG_count}++;
	  print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'z') {
	  $counting{total_unmethylated_CpG_count}++;
	  print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'H') {
	  $counting{total_meCHH_count}++;
	  print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'h') {
	  $counting{total_unmethylated_CHH_count}++;
	  print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq '.') {
	}
	else{
	  die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	}
      }
    }
    elsif ($strand eq '-') {

      unless ($ignore){  ### if --ignore was specified the start position has already been corrected
	$start += length($meth_call)-1;
      }

      for my $index (0..$#methylation_calls) {
	### methylated Cs (any context) will receive a forward (+) orientation
	### not methylated Cs (any context) will receive a reverse (-) orientation
	if ($methylation_calls[$index] eq 'X') {
	  $counting{total_meCHG_count}++;
	  print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'x') {
	  $counting{total_unmethylated_CHG_count}++;
	  print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'Z') {
	  $counting{total_meCpG_count}++;
	  print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'z') {
	  $counting{total_unmethylated_CpG_count}++;
	  print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'H') {
	  $counting{total_meCHH_count}++;
	  print {$fhs{other_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'h') {
	  $counting{total_unmethylated_CHH_count}++;
	  print {$fhs{other_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq '.'){
	}
	else{
	  die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	}
      }
    }
    else {
      die "This cannot happen (or at least it shouldn't....)\n";
    }
  }

  ### strand-specific methylation output
  elsif ($merge_non_CpG) {
    if ($strand eq '+') {
      for my $index (0..$#methylation_calls) {
	### methylated Cs (any context) will receive a forward (+) orientation
	### not methylated Cs (any context) will receive a reverse (-) orientation
	if ($methylation_calls[$index] eq 'X') {
	  $counting{total_meCHG_count}++;
	  print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'x') {
	  $counting{total_unmethylated_CHG_count}++;
	  print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'Z') {
	  $counting{total_meCpG_count}++;
	  print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'z') {
	  $counting{total_unmethylated_CpG_count}++;
	  print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'H') {
	  $counting{total_meCHH_count}++;
	  print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'h') {
	  $counting{total_unmethylated_CHH_count}++;
	  print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq '.') {
	}
	else{
	  die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	}
      }
    }
    elsif ($strand eq '-') {
      unless ($ignore){  ### if --ignore was specified the start position has already been corrected
	$start += length($meth_call)-1;
      }

      for my $index (0..$#methylation_calls) {
	### methylated Cs (any context) will receive a forward (+) orientation
	### not methylated Cs (any context) will receive a reverse (-) orientation
	if ($methylation_calls[$index] eq 'X') {
	  $counting{total_meCHG_count}++;
	  print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'x') {
	  $counting{total_unmethylated_CHG_count}++;
	  print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'Z') {
	  $counting{total_meCpG_count}++;
	  print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'z') {
	  $counting{total_unmethylated_CpG_count}++;
	  print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'H') {
	  $counting{total_meCHH_count}++;
	  print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq 'h') {
	  $counting{total_unmethylated_CHH_count}++;
	  print {$fhs{$filehandle_index}->{other_c}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq '.') {
	}
	else{
	  die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	}
      }
    }
    else {
      die "This cannot happen (or at least it shouldn't....)\n";
    }
  }

  ### THIS IS THE 3-CONTEXT (CpG, CHG and CHH) DEFAULT SECTION

  elsif ($full) {
    if ($strand eq '+') {
      for my $index (0..$#methylation_calls) {
	### methylated Cs (any context) will receive a forward (+) orientation
	### not methylated Cs (any context) will receive a reverse (-) orientation
	if ($methylation_calls[$index] eq 'X') {
	  $counting{total_meCHG_count}++;
	  print {$fhs{CHG_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'x') {
	  $counting{total_unmethylated_CHG_count}++;
	  print {$fhs{CHG_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'Z') {
	  $counting{total_meCpG_count}++;
	  print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'z') {
	  $counting{total_unmethylated_CpG_count}++;
	  print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'H') {
	  $counting{total_meCHH_count}++;
	  print {$fhs{CHH_context}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'h') {
	  $counting{total_unmethylated_CHH_count}++;
	  print {$fhs{CHH_context}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq '.') {}
	else{
	  die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	}
      }
    } elsif ($strand eq '-') {

      unless ($ignore){  ### if --ignore was specified the start position has already been corrected
	$start += length($meth_call)-1;
      }

      for my $index (0..$#methylation_calls) {
	### methylated Cs (any context) will receive a forward (+) orientation
	### not methylated Cs (any context) will receive a reverse (-) orientation
	if ($methylation_calls[$index] eq 'X') {
	  $counting{total_meCHG_count}++;
	  print {$fhs{CHG_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'x') {
	  $counting{total_unmethylated_CHG_count}++;
	  print {$fhs{CHG_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'Z') {
	  $counting{total_meCpG_count}++;
	  print {$fhs{CpG_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'z') {
	  $counting{total_unmethylated_CpG_count}++;
	  print {$fhs{CpG_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'H') {
	  $counting{total_meCHH_count}++;
	  print {$fhs{CHH_context}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'h') {
	  $counting{total_unmethylated_CHH_count}++;
	  print {$fhs{CHH_context}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq '.') {}
	else{
	  die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	}
      }
    } else {
      die "This cannot happen (or at least it shouldn't....)\n";
    }
  }

  ### strand-specific methylation output
  else {
    if ($strand eq '+') {
      for my $index (0..$#methylation_calls) {
	### methylated Cs (any context) will receive a forward (+) orientation
	### not methylated Cs (any context) will receive a reverse (-) orientation
	if ($methylation_calls[$index] eq 'X') {
	  $counting{total_meCHG_count}++;
	  print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'x') {
	  $counting{total_unmethylated_CHG_count}++;
	  print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'Z') {
	  $counting{total_meCpG_count}++;
	  print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'z') {
	  $counting{total_unmethylated_CpG_count}++;
	  print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'H') {
	  $counting{total_meCHH_count}++;
	  print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'+',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'h') {
	  $counting{total_unmethylated_CHH_count}++;
	  print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'-',$chrom,$start+$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq '.') {}
	else{
	  die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	}
      }
    }elsif ($strand eq '-') {

      unless ($ignore){  ### if --ignore was specified the start position has already been corrected
	$start += length($meth_call)-1;
      }

      for my $index (0..$#methylation_calls) {
	### methylated Cs (any context) will receive a forward (+) orientation
	### not methylated Cs (any context) will receive a reverse (-) orientation
	if ($methylation_calls[$index] eq 'X') {
	  $counting{total_meCHG_count}++;
	  print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'x') {
	  $counting{total_unmethylated_CHG_count}++;
	  print {$fhs{$filehandle_index}->{CHG}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'Z') {
	  $counting{total_meCpG_count}++;
	  print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'z') {
	  $counting{total_unmethylated_CpG_count}++;
	  print {$fhs{$filehandle_index}->{CpG}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'H') {
	  $counting{total_meCHH_count}++;
	  print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'+',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	} elsif ($methylation_calls[$index] eq 'h') {
	  $counting{total_unmethylated_CHH_count}++;
	  print {$fhs{$filehandle_index}->{CHH}} join ("\t",$id,'-',$chrom,$start-$index,$methylation_calls[$index]),"\n";
	}
	elsif ($methylation_calls[$index] eq '.') {}
	else{
	  die "The methylation call string contained the following unrecognised character: $methylation_calls[$index]\n";
	}
      }
    } else {
      die "This cannot happen (or at least it shouldn't....)\n";
    }
  }
}

sub print_helpfile{

 print << 'HOW_TO';


DESCRIPTION

The following is a brief description of all options to control the Bismark
methylation extractor. The script reads in a bisulfite read alignment results file 
produced by the Bismark bisulfite mapper and extracts the methylation information
for individual cytosines. This information is found in the methylation call field
which can contain the following characters:

       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       ~~~   X   for methylated C in CHG context (was protected)     ~~~
       ~~~   x   for not methylated C CHG (was converted)            ~~~
       ~~~   H   for methylated C in CHH context (was protected)     ~~~
       ~~~   h   for not methylated C in CHH context (was converted) ~~~
       ~~~   Z   for methylated C in CpG context (was protected)     ~~~
       ~~~   z   for not methylated C in CpG context (was converted) ~~~
       ~~~   .   for any bases not involving cytosines               ~~~
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The methylation extractor outputs result files for cytosines in CpG, CHG and CHH
context (this distinction is actually already made in Bismark itself). As the methylation
information for every C analysed can produce files which easily have tens or even hundreds of
millions of lines, file sizes can become very large and more difficult to handle. The C
methylation info additionally splits cytosine methylation calls up into one of the four possible
strands a given bisulfite read aligned against:

             OT      original top strand
             CTOT    complementary to original top strand

             OB      original bottom strand
             CTOB    complementary to original bottom strand

Thus, by default twelve individual output files are being generated per input file (unless
--comprehensive is specified, see below). The output files can be imported into a genome
viewer, such as SeqMonk, and re-combined into a single data group if desired (in fact
unless the bisulfite reads were generated preserving directionality it doesn't make any
sense to look at the data in a strand-specific manner). Strand-specific output files can
optionally be skipped, in which case only three output files for CpG, CHG or CHH context
will be generated. For both the strand-specific and comprehensive outputs there is also
the option to merge both non-CpG contexts (CHG and CHH) into one single non-CpG context.


The output files are in the following format (tab delimited):

<sequence_id>     <strand>      <chromosome>     <position>     <methylation call>


USAGE: methylation_extractor [options] <filenames>


ARGUMENTS:

<filenames>              A space-separated list of Bismark result files in SAM format from
                         which methylation information is extracted for every cytosine in
                         the reads. For alignment files in the older custom Bismark output
                         see option '--vanilla'.

OPTIONS:

-s/--single-end          Input file(s) are Bismark result file(s) generated from single-end
                         read data. Specifying either --single-end or --paired-end is
                         mandatory.

-p/--paired-end          Input file(s) are Bismark result file(s) generated from paired-end
                         read data. Specifying either --paired-end or --single-end is
                         mandatory.

--vanilla                The Bismark result input file(s) are in the old custom Bismark format
                         (up to version 0.5.x) and not in SAM format which is the default as
                         of Bismark version 0.6.x or higher. Default: OFF.

--no_overlap             For paired-end reads it is theoretically possible that read_1 and
                         read_2 overlap. This option avoids scoring overlapping methylation
                         calls twice. Whilst this removes a bias towards more methylation calls
                         towards the center of sequenced fragments it can de facto remove
                         a good proportion of the data.

--ignore <int>           Ignore the first <int> bp at the 5' end of each read when processing the
                         methylation call string. This can remove e.g. a restriction enzyme site
                         at the start of each read.

--comprehensive          Specifying this option will merge all four possible strand-specific 
                         methylation info into context-dependent output files. The default 
                         contexts are:
                          - CpG context
                          - CHG context
                          - CHH context

--merge_non_CpG          This will produce two output files (in --comprehensive mode) or eight
                         strand-specific output files (default) for Cs in
                          - CpG context
                          - non-CpG context

--report                 Prints out a short methylation summary as well as the paramaters used to run
                         this script.

--version                Displays version information.

-h/--help                Displays this help file and exits.


OUTPUT:

The output is in the form:

<seq-ID> <methylation state*> <chromosome> <start position (= end position)> <methylation call>

* Methylated cytosines receive a '+' orientation,
* Unmethylated cytosines receive a '-' orientation.


This script was last edited on 04 January 2012.

HOW_TO
}
